{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "038de38d-2821-4d84-b490-b1e2aede4fca",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Requirement already satisfied: nba_api in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (1.10.0)\n",
      "Requirement already satisfied: numpy>=2.1.0 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from nba_api) (2.3.1)\n",
      "Requirement already satisfied: pandas>=2.2.0 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from nba_api) (2.3.0)\n",
      "Requirement already satisfied: requests<3.0.0,>=2.32.3 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from nba_api) (2.32.4)\n",
      "Requirement already satisfied: charset_normalizer<4,>=2 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from requests<3.0.0,>=2.32.3->nba_api) (3.4.2)\n",
      "Requirement already satisfied: idna<4,>=2.5 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from requests<3.0.0,>=2.32.3->nba_api) (3.10)\n",
      "Requirement already satisfied: urllib3<3,>=1.21.1 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from requests<3.0.0,>=2.32.3->nba_api) (2.5.0)\n",
      "Requirement already satisfied: certifi>=2017.4.17 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from requests<3.0.0,>=2.32.3->nba_api) (2025.6.15)\n",
      "Requirement already satisfied: python-dateutil>=2.8.2 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from pandas>=2.2.0->nba_api) (2.9.0.post0)\n",
      "Requirement already satisfied: pytz>=2020.1 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from pandas>=2.2.0->nba_api) (2025.2)\n",
      "Requirement already satisfied: tzdata>=2022.7 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from pandas>=2.2.0->nba_api) (2025.2)\n",
      "Requirement already satisfied: six>=1.5 in c:\\users\\syedr\\appdata\\local\\programs\\python\\python313\\lib\\site-packages (from python-dateutil>=2.8.2->pandas>=2.2.0->nba_api) (1.17.0)\n",
      "done\n"
     ]
    }
   ],
   "source": [
    "# Standard Python libraries\n",
    "from io import StringIO\n",
    "try:\n",
    "    import os\n",
    "except:\n",
    "    print('Error')\n",
    "try:\n",
    "    import time\n",
    "except :\n",
    "    print(\"‚ö†Ô∏è  not installed ‚Äì skipping.\")\n",
    "try:\n",
    "    import json\n",
    "except : \n",
    "    print(\"‚ö†Ô∏è  not installed ‚Äì skipping. Install \") \n",
    "try:\n",
    "    import requests\n",
    "except : \n",
    "    print(\"‚ö†Ô∏è  not installed ‚Äì skipping. Install \") \n",
    "# Data manipulation and analysis\n",
    "try:\n",
    "    import pandas as pd\n",
    "except : \n",
    "    print(\"‚ö†Ô∏è  not installed ‚Äì skipping. Install \") \n",
    "try:\n",
    "    import numpy as np\n",
    "except : \n",
    "    print(\"‚ö†Ô∏è  not installed ‚Äì skipping. Install \")\n",
    "# Data visualization (optional, for plotting)\n",
    "try:\n",
    "    import matplotlib.pyplot as plt\n",
    "except : \n",
    "    print(\"‚ö†Ô∏è  not installed ‚Äì skipping. Install \") \n",
    "try:\n",
    "    import seaborn as sns\n",
    "except:\n",
    "    print('kindly install it')\n",
    "# API and HTTP\n",
    "from nba_api.stats.endpoints import leaguegamefinder, commonteamroster\n",
    "from nba_api.stats.static import teams\n",
    "!pip install nba_api\n",
    "# Display options\n",
    "pd.set_option('display.max_columns', None)\n",
    "pd.set_option('display.width', 1000)\n",
    "\n",
    "# Warnings\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "print('done')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "811fc2c6-2fee-46a7-8809-bf10bf344131",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import io\n",
    "import json\n",
    "import zipfile\n",
    "import mimetypes\n",
    "import requests\n",
    "import pandas as pd\n",
    "\n",
    "class SmartDownloader:\n",
    "    def __init__(self, url, filename=None, save_dir='downloads'):\n",
    "        self.url = url\n",
    "        self.filename = filename or \"downloaded_data\"\n",
    "        self.save_dir = save_dir\n",
    "        self.response = None\n",
    "\n",
    "        if not os.path.exists(self.save_dir):\n",
    "            os.makedirs(self.save_dir)\n",
    "\n",
    "    def download(self):\n",
    "        try:\n",
    "            self.response = requests.get(self.url)\n",
    "            self.response.raise_for_status()\n",
    "            content_type = self.response.headers.get('Content-Type', '')\n",
    "\n",
    "            if 'application/json' in content_type or self.url.endswith('.json'):\n",
    "                self.filename += \".json\"\n",
    "            elif 'text/html' in content_type or self.url.endswith('.html'):\n",
    "                self.filename += \".html\"\n",
    "            elif 'text/csv' in content_type or self.url.endswith('.csv'):\n",
    "                self.filename += \".csv\"\n",
    "            else:\n",
    "                self.filename += \".data\"\n",
    "\n",
    "            self.file_path = os.path.join(self.save_dir, self.filename)\n",
    "            with open(self.file_path, 'wb') as f:\n",
    "                f.write(self.response.content)\n",
    "\n",
    "            print(f\"‚úÖ File downloaded: {self.file_path}\")\n",
    "            return self.file_path\n",
    "        except Exception as e:\n",
    "            print(f\"‚ùå Download error: {e}\")\n",
    "            return None\n",
    "\n",
    "    def to_dataframe(self, table_index=0):\n",
    "        try:\n",
    "            ext = self.filename.split('.')[-1].lower()\n",
    "\n",
    "            if ext == 'json':\n",
    "                data = self.response.json()\n",
    "\n",
    "                # If JSON is a list of dicts with nested fields like \"nutritions\"\n",
    "                df = pd.json_normalize(data)\n",
    "                print(f\"‚úÖ JSON data converted to DataFrame: {df.shape}\")\n",
    "                return df\n",
    "\n",
    "            elif ext in ['csv']:\n",
    "                return pd.read_csv(self.file_path)\n",
    "\n",
    "            elif ext in ['xls', 'xlsx']:\n",
    "                return pd.read_excel(self.file_path)\n",
    "\n",
    "            elif ext in ['html', 'htm']:\n",
    "                tables = pd.read_html(self.file_path)\n",
    "                print(f\"üìÑ Found {len(tables)} HTML tables\")\n",
    "                return tables[table_index]\n",
    "\n",
    "            else:\n",
    "                raise ValueError(\"Unsupported format for conversion\")\n",
    "\n",
    "        except Exception as e:\n",
    "            print(f\"‚ùå Failed to convert to DataFrame: {e}\")\n",
    "            return None\n",
    "\n",
    "    def fetch(self, table_index=0):\n",
    "        if self.download():\n",
    "            return self.to_dataframe(table_index=table_index)\n",
    "        return None\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "024d47d5-b263-4b87-859b-ebcd49fb3e36",
   "metadata": {},
   "outputs": [],
   "source": [
    "def dict_create(list_dict):\n",
    "    keys=list_dict[0].keys()\n",
    "    out_dict={key:[] for key in keys}\n",
    "    for dict_ in list_dict:\n",
    "        for key, value in dict_.items():\n",
    "            out_dict[key].append(value)\n",
    "    return out_dict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "01654534-80ea-4743-a081-610548e2fb07",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import requests\n",
    "from io import StringIO\n",
    "\n",
    "class WikipediaTableDownloader:\n",
    "    def __init__(self, url, ssl_verify=True):\n",
    "        self.url = url\n",
    "        self.ssl_verify = ssl_verify\n",
    "        self.tables = []\n",
    "        self.df = None\n",
    "\n",
    "    def fetch_tables(self):\n",
    "        \"\"\"Fetch tables from the HTML content.\"\"\"\n",
    "        try:\n",
    "            response = requests.get(self.url, verify=self.ssl_verify)\n",
    "            response.raise_for_status()\n",
    "            html = response.text\n",
    "            self.tables = pd.read_html(StringIO(html))\n",
    "            print(f\"‚úÖ Found {len(self.tables)} tables.\")\n",
    "        except Exception as e:\n",
    "            print(f\"‚ùå Error fetching tables: {e}\")\n",
    "\n",
    "    def select_table(self, index=0):\n",
    "        \"\"\"Select a table by index.\"\"\"\n",
    "        if self.tables and 0 <= index < len(self.tables):\n",
    "            self.table = self.tables[index]\n",
    "            self.converted=pd.DataFrame(self.table)\n",
    "            self.df= self.converted\n",
    "            print(f\"‚úÖ Selected table {index}\")\n",
    "        else:\n",
    "            print(f\"‚ùå Table index {index} is out of range.\")\n",
    "\n",
    "    def save_csv(self, filename=\"output.csv\"):\n",
    "        \"\"\"Save the selected table to CSV.\"\"\"\n",
    "        if self.df is not None:\n",
    "            self.df.to_csv(filename, index=False)\n",
    "            print(f\"üíæ Table saved to {filename}\")\n",
    "        else:\n",
    "            print(\"‚ùå No table selected to save.\")\n",
    "\n",
    "    def get_dataframe(self):\n",
    "        \"\"\"Return the selected DataFrame.\"\"\"\n",
    "        return self.df\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "8d250cbb-8154-4da0-961a-3968769fe13c",
   "metadata": {},
   "outputs": [],
   "source": [
    "class save_csv(object):\n",
    "    def __init__(self, filename, df=None):\n",
    "        self.filename = filename\n",
    "        self.df = df\n",
    "\n",
    "    def save_csv(self):\n",
    "        \"\"\"Save the DataFrame to CSV if it exists.\"\"\"\n",
    "        if self.df is not None:\n",
    "            self.df.to_csv(self.filename, index=False)\n",
    "            print(f\"üíæ Table saved to {self.filename}\")\n",
    "        else:\n",
    "            print(\"‚ùå No DataFrame to save.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "20a4d570-0f46-4117-97ad-14f7a076c939",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "\n",
    "class DataFrameTypeChanger:\n",
    "    def __init__(self, df):\n",
    "        self.df = df\n",
    "\n",
    "    def show_types(self):\n",
    "        \"\"\"Print current data types of all columns\"\"\"\n",
    "        print(\"üîç Current Data Types:\")\n",
    "        print(self.df.dtypes)\n",
    "\n",
    "    def change_type(self, column, new_type):\n",
    "        \"\"\"Change the type of a single column\"\"\"\n",
    "        try:\n",
    "            self.df[column] = self.df[column].astype(new_type)\n",
    "            print(f\"‚úÖ Column '{column}' converted to {new_type}\")\n",
    "        except Exception as e:\n",
    "            print(f\"‚ùå Failed to convert column '{column}': {e}\")\n",
    "\n",
    "    def change_multiple_types(self, type_dict):\n",
    "        \"\"\"Change types of multiple columns using a dictionary\"\"\"\n",
    "        for column, new_type in type_dict.items():\n",
    "            self.change_type(column, new_type)\n",
    "\n",
    "    def auto_convert_numerics(self, columns):\n",
    "        \"\"\"Automatically convert selected columns to numeric (int/float)\"\"\"\n",
    "        for column in columns:\n",
    "            try:\n",
    "                self.df[column] = pd.to_numeric(self.df[column], errors='coerce')\n",
    "                print(f\"‚úÖ Auto-converted '{column}' to numeric\")\n",
    "            except Exception as e:\n",
    "                print(f\"‚ùå Failed to convert '{column}' to numeric: {e}\")\n",
    "    def rename_columns(self, new_names):\n",
    "        \"\"\"\n",
    "        Rename DataFrame columns using a provided list of names.\n",
    "\n",
    "        Parameters:\n",
    "        - new_names (list): A list of new column names in correct order.\n",
    "\n",
    "        Returns:\n",
    "        - None. Modifies df in-place.\n",
    "        \"\"\"\n",
    "        if len(new_names) != len(self.df.columns):\n",
    "            print(\"‚ùå Length mismatch: number of new names must equal number of columns.\")\n",
    "        else:\n",
    "            self.df.columns = new_names\n",
    "            print(f\"‚úÖ Columns renamed to: {new_names}\")\n",
    "\n",
    "    def get_dataframe(self):\n",
    "        \"\"\"Return the modified DataFrame\"\"\"\n",
    "        return self.df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "e4f4b23e-f95f-4d43-99a4-bd4af5d289bf",
   "metadata": {},
   "outputs": [],
   "source": [
    "from randomuser import RandomUser\n",
    "\n",
    "class RandomUserFetcher:\n",
    "    def __init__(self, num_users=1):\n",
    "        \"\"\"\n",
    "        Initialize the class by generating a list of random users.\n",
    "\n",
    "        Parameters:\n",
    "        - num_users (int): Number of random users to generate (default = 1)\n",
    "        \"\"\"\n",
    "        self.num_users = num_users\n",
    "        # Generate the requested number of random users and store them\n",
    "        self.users = RandomUser.generate_users(self.num_users)\n",
    "\n",
    "    def get_attributes(self, attributes):\n",
    "        \"\"\"\n",
    "        Extract specific attributes from each random user.\n",
    "\n",
    "        Parameters:\n",
    "        - attributes (list): List of attribute names (as strings),\n",
    "                             e.g., ['first_name', 'email', 'gender']\n",
    "\n",
    "        Returns:\n",
    "        - A list of dictionaries, each representing a user with the selected attributes\n",
    "        \"\"\"\n",
    "        all_data = []\n",
    "\n",
    "        # Loop through each generated user\n",
    "        for user in self.users:\n",
    "            user_data = {}  # Dictionary to store extracted data for this user\n",
    "\n",
    "            # For each requested attribute (e.g., 'email', 'gender')\n",
    "            for attr in attributes:\n",
    "                # Build the method name like 'get_email', 'get_gender'\n",
    "                method_name = f'get_{attr}'\n",
    "\n",
    "                # Check if the method exists in the user object\n",
    "                if hasattr(user, method_name):\n",
    "                    # Dynamically call the method\n",
    "                    value = getattr(user, method_name)()\n",
    "                    user_data[attr] = value\n",
    "                else:\n",
    "                    # If attribute not found, set it to None\n",
    "                    user_data[attr] = None\n",
    "\n",
    "            # Add the dictionary to the list\n",
    "            all_data.append(user_data)\n",
    "\n",
    "        df = pd.DataFrame(all_data)\n",
    "        return df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "c80a6955-85d1-479b-8982-741cbd96b153",
   "metadata": {},
   "outputs": [],
   "source": [
    "import requests\n",
    "import json\n",
    "import pandas as pd\n",
    "import re\n",
    "import os\n",
    "from urllib.parse import urlparse\n",
    "\n",
    "class JSONDownloader:\n",
    "    def __init__(self, url):\n",
    "        self.url = url\n",
    "        self.response = None\n",
    "        self.df = None\n",
    "\n",
    "    def download(self):\n",
    "        try:\n",
    "            self.response = requests.get(self.url)\n",
    "            self.response.raise_for_status()\n",
    "            print(\"‚úÖ JSON downloaded successfully\")\n",
    "        except Exception as e:\n",
    "            print(f\"‚ùå Download failed: {e}\")\n",
    "\n",
    "    def to_dataframe(self):\n",
    "        if self.response is None:\n",
    "            print(\"‚ö†Ô∏è No response to convert. Please download first.\")\n",
    "            return None\n",
    "\n",
    "        try:\n",
    "            data = json.loads(self.response.text)\n",
    "            self.df = pd.DataFrame(data)\n",
    "\n",
    "            # Normalize nested columns if needed\n",
    "            for col in self.df.columns:\n",
    "                if isinstance(self.df[col][0], dict):\n",
    "                    nested = pd.json_normalize(self.df[col])\n",
    "                    self.df = self.df.drop(columns=[col]).join(nested)\n",
    "\n",
    "            print(f\"‚úÖ Data converted to DataFrame: {self.df.shape}\")\n",
    "            return self.df\n",
    "        except Exception as e:\n",
    "            print(f\"‚ùå Conversion error: {e}\")\n",
    "            return None\n",
    "\n",
    "    def fetch(self):\n",
    "        self.download()\n",
    "        return self.to_dataframe()\n",
    "        \n",
    "    def save(self, filename):\n",
    "        if self.df is not None:\n",
    "            self.df.to_csv(filename, index=False)\n",
    "            print(f\"‚úÖ DataFrame saved as '{filename}'\")\n",
    "        else:\n",
    "            print(\"‚ö†Ô∏è No DataFrame to save. Please fetch first.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "292de457-3ddc-43f0-b831-e953409b5a66",
   "metadata": {},
   "outputs": [],
   "source": [
    "import json\n",
    "import pandas as pd\n",
    "\n",
    "def JSON_to_dataframe(response_text):\n",
    "    try:\n",
    "        data = json.loads(response_text)\n",
    "        df = pd.DataFrame(data)\n",
    "\n",
    "        # Normalize nested columns\n",
    "        for col in df.columns:\n",
    "            if isinstance(df[col][0], dict):\n",
    "                nested = pd.json_normalize(df[col])\n",
    "                df = df.drop(columns=[col]).join(nested)\n",
    "\n",
    "        print(f\"‚úÖ Data converted to DataFrame: {df.shape}\")\n",
    "        return df\n",
    "    except Exception as e:\n",
    "        print(f\"‚ùå Conversion error: {e}\")\n",
    "        return None\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "ba487ab6-493d-4df8-9718-ac3a97933a28",
   "metadata": {},
   "outputs": [],
   "source": [
    "class TextAnalyzer(object):\n",
    "    def __init__(self,text):\n",
    "        formattedText = text.replace('.',' ').replace(',',' ').replace('?',' ').replace('!',',')\n",
    "        formattedText = formattedText.lower()\n",
    "        self.Text = formattedText\n",
    "    def freqAll(self):\n",
    "        wordList = self.Text.split(' ')\n",
    "        Dict = {}\n",
    "        for word in set(wordList):\n",
    "            Dict[word] = wordList.count(word)\n",
    "        return Dict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "70019f17-d983-4563-afac-71fd056244dc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def one_dict(list_dict):\n",
    "    keys=list_dict[0].keys()\n",
    "    out_dict={key:[] for key in keys}\n",
    "    for dict_ in list_dict:\n",
    "        for key, value in dict_.items():\n",
    "            out_dict[key].append(value)\n",
    "    return out_dict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "97e71b19-2a41-4141-aa5a-d236ceccf859",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
